# Notification System

The notification system handles scheduled reminders for Bible study sessions. It processes schedules, generates notifications, and delivers them via email or SMS.

## Overview

Notifications are generated by the cron system and delivered through multiple channels:
- **Email**: Primary delivery method
- **SMS**: Secondary delivery via SignalWire

## Architecture

```
App/
├── Cron/
│   ├── ScheduleProcessor.php      # Generates notifications from schedules
│   ├── StudyProcessor.php         # Processes study-related tasks
│   └── CronLogging.php            # Cron execution logging
├── Logic/
│   └── Services/
│       ├── NotificationService.php  # Business logic for notifications
│       ├── EmailService.php         # Email delivery
│       └── SMSService.php           # SMS delivery
└── Data/
    ├── Repositories/
    │   └── NotificationRepository.php # Data access
    └── Clients/
        └── SignalWireClient.php     # SMS provider client
```

## Notification Lifecycle

### 1. Schedule Creation

When a user creates a study with a schedule:

```php
$schedule = $scheduleService->create([
    'study_id' => $studyId,
    'pattern' => [1, 3, 7, 14, 30],  // Days between reviews
    'timezone' => 'America/New_York'
]);
```

### 2. Cron Processing

The `ScheduleProcessor` runs periodically to generate notifications:

```php
// Query schedules needing notifications
$schedules = $pdo->query("
    SELECT s.* FROM schedules s
    LEFT JOIN notifications n ON s.id = n.schedule_id AND n.status = 1
    WHERE s.status = 1 AND n.id IS NULL
")->fetchAll();

// Create notification for each
foreach ($schedules as $schedule) {
    $this->createNotificationForSchedule($schedule);
}
```

### 3. Notification Generation

```php
private function createNotificationForSchedule(array $schedule): void {
    // Build notification content
    $subject = $this->subjectBuilder->build($study, $schedule);
    $content = $this->contentBuilder->build($study, $schedule);
    
    // Calculate send time
    $sendAt = $this->calculateSendTime($schedule, $userTimezone);
    
    // Create notification record
    $notificationId = $this->notificationRepository->create([
        'schedule_id' => $schedule['id'],
        'user_id' => $study['user_id'],
        'subject' => $subject,
        'content' => $content,
        'send_at' => $sendAt,
        'status' => 1,  // Active
        'sent' => 0     // Not yet sent
    ]);
}
```

### 4. Delivery

Notifications are delivered by `NotificationService`:

```php
class NotificationService {
    public function sendEmailNotification(array $notification): Result {
        return $this->emailService->send(
            to: $notification['user_email'],
            subject: $notification['subject'],
            body: $notification['content'],
            notification: $notification
        );
    }
    
    public function sendSmsNotification(array $notification): Result {
        // Validate phone
        if (!$user['phone_validated']) {
            return Result::error('Phone not validated');
        }
        
        // Send via SignalWire
        return $this->signalWireClient->sendSms(
            to: $user['phone'],
            message: $this->formatForSms($notification)
        );
    }
}
```

## Database Schema

### notifications Table

```sql
CREATE TABLE notifications (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    schedule_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    subject TEXT NOT NULL,
    content TEXT NOT NULL,
    send_at DATETIME NOT NULL,
    status INTEGER DEFAULT 1,  -- 1=active, 0=inactive
    sent INTEGER DEFAULT 0,    -- 0=pending, 1=sent
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## Content Building

### Subject Builder

```php
class NotificationSubjectBuilder {
    public function build(array $study, array $schedule): string {
        $reference = $study['reference'] ?? 'Study';
        $pattern = $schedule['pattern'] ?? [];
        $position = $schedule['position'] ?? 0;
        
        return "[{$reference}] Review #{$position}";
    }
}
```

### Content Builder

```php
class NotificationContentBuilder {
    public function build(array $study, array $schedule): string {
        $reference = $study['reference'];
        $text = $study['text'] ?? '';
        
        return "Time to review: {$reference}\n\n{$text}";
    }
}
```

## SMS Delivery

### SignalWire Integration

```php
class SignalWireClient {
    public function sendSms(string $to, string $message): array {
        $response = $this->httpClient->post('/api/laml/2010-04-01/Accounts/{account}/Messages.json', [
            'From' => $this->fromNumber,
            'To' => $to,
            'Body' => $message
        ]);
        
        return [
            'success' => true,
            'messageId' => $response['sid']
        ];
    }
}
```

### Phone Validation

Users must validate their phone number before receiving SMS:

```php
// Generate validation code
$code = random_int(100000, 999999);

// Send validation SMS
$signalWire->sendSms($phone, "Your code: {$code}");

// Store hashed code
$userRepository->setPhoneValidationCode($userId, password_hash($code, PASSWORD_DEFAULT));
```

## Cron Execution

Run the notification processor via cron:

```bash
# Every 5 minutes
*/5 * * * * cd /var/www/application && php bin/process-schedules.php
```

### Process Script

```php
#!/usr/bin/env php
<?php
require_once __DIR__ . '/../vendor/autoload.php';

$pdo = new PDO('sqlite:' . __DIR__ . '/../Data/application.db');
$logger = new CronLogging();
$scheduleApi = new ScheduleApiClient($config);

$processor = new ScheduleProcessor(
    $pdo,
    $logger,
    $scheduleApi,
    $scheduleService,
    $studyService,
    $contentBuilder,
    $subjectBuilder,
    $config
);

$output = $processor->processSchedules();
echo $output;
```

## Public Notification View

Notifications can be viewed publicly via encrypted links:

```php
// Generate encrypted link
$token = $encryption->encrypt($notificationId);
$link = "https://memorize.live/notify/{$token}";

// In PublicNotifyController
public function view(array $request): array {
    $token = $request['params']['token'] ?? '';
    $notificationId = $this->encryption->decrypt($token);
    
    $notification = $this->notificationRepository->findById($notificationId);
    
    return ResponseBuilder::success(
        data: ['notification' => $notification],
        template: 'Public/notify'
    );
}
```

## Best Practices

### 1. Idempotent Generation

Only create notifications when none exist:

```sql
LEFT JOIN notifications n ON s.id = n.schedule_id AND n.status = 1
WHERE n.id IS NULL
```

### 2. Timezone Handling

Always use user's timezone for scheduling:

```php
$sendAt = new DateTime('now', new DateTimeZone($userTimezone));
$sendAt->modify('+1 day');
```

### 3. Graceful Degradation

If SMS fails, still mark notification for email:

```php
$result = $notificationService->sendSmsNotification($notification);
if (!$result->isSuccess()) {
    error_log("SMS failed, falling back to email: " . $result->getError());
}
```

### 4. Rate Limiting

Prevent SMS spam:

```php
$recentCount = $notificationRepository->countRecentSms($userId, '1 hour');
if ($recentCount > 10) {
    return Result::error('Rate limit exceeded');
}
```

---

**Status:** Accurate and Complete  
**Last Updated:** 2025-02-08
